<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop面试题汇总</title>
    <url>/2021/11/29/Hadoop%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea01——使用技巧及快捷键</title>
    <url>/2021/11/29/Idea01%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>工具和中间件</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn01——HA实现原理</title>
    <url>/2021/11/29/Yarn01%E2%80%94%E2%80%94HA%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>大数据体系</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse01——发展</title>
    <url>/2021/11/29/clickhouse01%E2%80%94%E2%80%94%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ClickHouse</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>hive面试题汇总</title>
    <url>/2021/11/29/hive%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>image</title>
    <url>/2021/11/24/image/</url>
    <content><![CDATA[<p><img src="/2021/11/24/image/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%B7%AF%E7%BA%BF.png"></p>
]]></content>
  </entry>
  <entry>
    <title>计算计网络面试题汇总</title>
    <url>/2021/11/29/i%E7%AE%97%E8%AE%A1%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试题汇总</title>
    <url>/2021/11/29/java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>spark面试题汇总</title>
    <url>/2021/11/29/spark%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode01——两数之和</title>
    <url>/2021/11/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h3 id="解；"><a href="#解；" class="headerlink" title="解；"></a>解；</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.leetcode01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> leetcode.leetcode03.Leetcode03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leetcode01 num = <span class="keyword">new</span> Leetcode01();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(num.twoSum(nums,<span class="number">9</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>在计算机程序中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情，如下图所示。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/1.png" alt="image.png" style="zoom: 50%;">

<p>反观二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/2.png" alt="image.png" style="zoom: 50%;">

<p>那么，二叉树都有哪些遍历方式呢？</p>
<p>从节点之间位置关系的角度来看，二叉树的遍历分为 4 种。</p>
<ol>
<li>前序遍历。</li>
<li>中序遍历。</li>
<li>后序遍历。</li>
<li>层序遍历。</li>
</ol>
<p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p>
<ol>
<li>深度优先遍历（前序遍历、中序遍历、后序遍历）。</li>
<li>广度优先遍历（层序遍历）。</li>
</ol>
<p>下面就来具体看一看这些不同的遍历方式。</p>
<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。</p>
<p>所谓深度优先，顾名思义，就是偏向于纵深，「一头扎到底」的访问方式。可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍历、后序遍历，来看一看深度优先是怎么回事吧。</p>
<h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h3><p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/3.png" alt="image.png" style="zoom: 50%;">

<p>上图就是一个二叉树的前序遍历，每个节点左侧的序号代表该节点的输出顺序。</p>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h3><p>二叉树的中序遍历，输出顺序是左子树、根节点、右子树。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/4.png" alt="image.png" style="zoom: 50%;">

<p>上图就是一个二叉树的中序遍历，每个节点左侧的序号代表该节点的输出顺序。</p>
<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><p>二叉树的后序遍历，输出顺序是左子树、右子树、根节点。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/5.png" alt="image.png" style="zoom: 50%;">

<p>上图就是一个二叉树的后序遍历，每个节点左侧的序号代表该节点的输出顺序。</p>
<p>由于二叉树的后序遍历和前序、中序遍历的思想大致相同，算法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputList 输入序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt;inputList)</span></span>&#123;</span><br><span class="line">    TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (inputList == <span class="keyword">null</span> || inputList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer data = inputList.removeFirst();</span><br><span class="line">    <span class="comment">// 这里的判空很关键：如果元素是空，则不在进一步递归</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">        node.leftChild = createBinaryTree(inputList);</span><br><span class="line">        node.rightChild = createBinaryTree(inputList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    preOrderTraveral(node.leftChild);</span><br><span class="line">    preOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraveral(node.leftChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    inOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraveral(node.leftChild);</span><br><span class="line">    postOrderTraveral(node.rightChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode leftChild;</span><br><span class="line">    TreeNode rightChild;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; inputList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(Arrays.</span><br><span class="line">              asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,</span><br><span class="line">              <span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createBinaryTree(inputList);</span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    preOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    inOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    postOrderTraveral(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树用递归方式来实现前序、中序、后序遍历，是最为自然的方式，因此代码也非常简单。</p>
<p>这 3 种遍历方式的区别，仅仅是输出的执行位置不同：前序遍历的输出在前，中序遍历的输出在中间，后序遍历的输出在最后。</p>
<p>代码中值得注意的一点是二叉树的构建。二叉树的构建方法有很多，这里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩子为空的情况。</p>
<p>在代码的 main 函数中，通过 <code>&#123;3,2,9,null,null,10,null,null,8,null,4&#125;</code> 这样一个线性序列，构建成的二叉树如下。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/6.png" alt="image.png" style="zoom: 50%;">

<p>绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈。因为递归和栈都有回溯的特性。</p>
<p>如何借助栈来实现二叉树的非递归遍历，下面以二叉树的前序遍历为例，看具体过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树非递归前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveralWithStack</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    <span class="keyword">while</span>(treeNode!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//迭代访问节点的左孩子，并入栈</span></span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(treeNode.data);</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            treeNode = treeNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至于二叉树的中序、后序遍历的非递归实现，思路和前序遍历差不太多，都是利用栈来进行回溯。各位读者要是有兴趣的话，可以自己尝试用代码实现一下。</p>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>如果说深度优先遍历是在一个方向上「一头扎到底」，那么广度优先遍历则恰恰相反：先在各个方向上各走出 1 步，再在各个方向上走出第 2 步、第 3 步……一直到各个方向全部走完。听起来有些抽象，下面让我们通过二叉树的层序遍历，来看一看广度优先是怎么回事。</p>
<p>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p>
<img src="/2021/11/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/7.png" alt="image.png" style="zoom: 50%;">

<p>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。二叉树同一层次的节点之间是没有直接关联的，需要借助一个数据结构来辅助工</p>
<p>作，这个数据结构就是 <strong>队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树层序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>半小时漫画三国演义</title>
    <url>/2021/11/29/%E5%8D%8A%E5%B0%8F%E6%97%B6%E6%BC%AB%E7%94%BB%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔记录</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速学会炒股</title>
    <url>/2021/11/29/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9A%E7%82%92%E8%82%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>宜家-杭州</title>
    <url>/2021/11/25/%E5%AE%9C%E5%AE%B6-%E6%9D%AD%E5%B7%9E/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>在杭州</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/11/29/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据库面试题汇总</title>
    <url>/2021/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法面试题汇总</title>
    <url>/2021/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题汇总</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>横店影视城-金华</title>
    <url>/2021/11/25/%E6%A8%AA%E5%BA%97%E5%BD%B1%E8%A7%86%E5%9F%8E-%E9%87%91%E5%8D%8E/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>在杭州</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>湘湖-杭州</title>
    <url>/2021/11/25/%E6%B9%98%E6%B9%96-%E6%9D%AD%E5%B7%9E/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>在杭州</category>
      </categories>
  </entry>
  <entry>
    <title>维度建模</title>
    <url>/2021/11/29/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>行情系统的基本设计</title>
    <url>/2021/11/29/%E8%A1%8C%E6%83%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>行情</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络01——计网知识点</title>
    <url>/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01%E2%80%94%E2%80%94%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>程序设计基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架01——ArrayList</title>
    <url>/2021/11/29/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B601%E2%80%94%E2%80%94ArrayList/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java生态</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架01——LinkedList</title>
    <url>/2021/11/29/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B601%E2%80%94%E2%80%94LinkedList/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java生态</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
